# Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법!

현재의 선택이 나중에 미칠 영향은 고려하지 않는다.

### 거스름돈

손님에게 거슬러 줘야할 돈이 N원일때 거슬러줘야할 동전의 최소 개수를 구하라. 단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.

----

> 가장 큰 화폐 단위부터 돈을 거슬러 주는 방법!

만약 N이 1260원이라면, 500원 2개, 100원 2개, 50원 1개, 10원 1개로 총 6개의 동전이 최소 개수이다.

```python
def greedy_3_1(n):
    count = 0

    coin_type = [500, 100, 50, 10]

    for coin in coin_type:
        count += n // coin
        n %= coin

    print(count)

greedy_3_1(1260)
```

화폐 종류만큼 반복하기 때문에 화폐의 종류가 K개라면 시간 복잡도는 `O(K)`이다. 동전의 종류에만 영향을 받고 금액의 크기와는 무관하다.

가지고 있는 동전 중 큰 단위가 항상 작은 단위의 배수이기 때문에 가능한 방법이다. 만약 400원 단위가 존재한다면 그리디로 동전의 최소 개수를 구할 수 없다.

### 큰 수의 법칙

다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 `M번` 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 `K번을 초과`하여 더해질 수 없다.

예를 들어 배열이 [2,4,5,4,6]인데 M=8, K=3일때, 6+6+6+5+6+6+6+5로 46이다. [4,3,4,3,4]라면, 4+4+4+4+4+4+4+4인 28이다.

입력조건은 첫째 줄에 N, M, K 자연수가 주어진다. 둘째 줄에 `N개`의 자연수가 주어진다. K는 항상 M보다 작거나 같다.

예시)
5 8 3
2 4 5 4 6
출력 : 46

N=5, M=9, K=3이면, (6+6+6+5)+(6+6+6+5)+(6)이다. 가장 큰 수인 6이 더해지는 횟수는 총 7번이다. M//(K+1)=2이다. 2*K가 완전한 한 사이클이 돌아간 6의 더해진 횟수이다. M%(K+1)=1이다. (M//(K+1) * K)+(M%(K+1))이 6이 더해진 횟수이다.

```python
def greed_3_2():
    n, m, k = map(int, input().split())

    arr = list(map(int, input().split()))
    arr.sort()

    # arr[n-1]이 더해지는 횟수
    count = ((m // (k + 1)) * k) + (m % (k + 1))

    result = 0
    result += arr[n - 1] * count
    result += arr[n - 2] * (m - count)
    print(result)

greedy_3_2()
```