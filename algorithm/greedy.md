# Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법!

현재의 선택이 나중에 미칠 영향은 고려하지 않는다.

### 거스름돈

손님에게 거슬러 줘야할 돈이 N원일때 거슬러줘야할 동전의 최소 개수를 구하라. 단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.

----

> 가장 큰 화폐 단위부터 돈을 거슬러 주는 방법!

만약 N이 1260원이라면, 500원 2개, 100원 2개, 50원 1개, 10원 1개로 총 6개의 동전이 최소 개수이다.

```python
def greedy_3_1(n):
    count = 0

    coin_type = [500, 100, 50, 10]

    for coin in coin_type:
        count += n // coin
        n %= coin

    print(count)

greedy_3_1(1260)
```

화폐 종류만큼 반복하기 때문에 화폐의 종류가 K개라면 시간 복잡도는 `O(K)`이다. 동전의 종류에만 영향을 받고 금액의 크기와는 무관하다.

가지고 있는 동전 중 큰 단위가 항상 작은 단위의 배수이기 때문에 가능한 방법이다. 만약 400원 단위가 존재한다면 그리디로 동전의 최소 개수를 구할 수 없다.

### 큰 수의 법칙

다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 `M번` 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 `K번을 초과`하여 더해질 수 없다.

예를 들어 배열이 [2,4,5,4,6]인데 M=8, K=3일때, 6+6+6+5+6+6+6+5로 46이다. [4,3,4,3,4]라면, 4+4+4+4+4+4+4+4인 28이다.

입력조건은 첫째 줄에 N, M, K 자연수가 주어진다. 둘째 줄에 `N개`의 자연수가 주어진다. K는 항상 M보다 작거나 같다.

예시)
5 8 3
2 4 5 4 6
출력 : 46

N=5, M=9, K=3이면, (6+6+6+5)+(6+6+6+5)+(6)이다. 가장 큰 수인 6이 더해지는 횟수는 총 7번이다. M//(K+1)=2이다. 2*K가 완전한 한 사이클이 돌아간 6의 더해진 횟수이다. M%(K+1)=1이다. (M//(K+1) * K)+(M%(K+1))이 6이 더해진 횟수이다.

```python
def greedy_3_2():
    n, m, k = map(int, input().split())

    arr = list(map(int, input().split()))
    arr.sort()

    # arr[n-1]이 더해지는 횟수
    count = ((m // (k + 1)) * k) + (m % (k + 1))

    result = 0
    result += arr[n - 1] * count
    result += arr[n - 2] * (m - count)
    print(result)

greedy_3_2()
```

### 숫자 카드 게임

여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 카드는 N * M(행 * 열) 형태로 놓여있다. 먼저 뽑고자 하는 카드가 포함된 행을 선택하고 선택 된 행의 카드들 중 가장 숫자가 낮은 카드를 뽑는다. 처음 카드를 골라낼 행을 선택할 때, 이후 해당 행에서 가장 숫자가 낮은 카드를 뽑는 것을 고려하여 최종적으로 가장 높은 카드를 뽑아야한다.

예시)
3 3
3 1 2
4 1 4
2 2 2
출력 : 2

2 4
7 3 1 8
3 3 3 4
출력 : 3

```python
def greedy_3_3():
    n, m = map(int, input().split())
    result = []
    for i in range(n):
        arr = list(map(int, input().split()))
        arr.sort()
        result.append(arr[0]) # 각 행의 가장 작은 수 list
    print(max(result)) # 그 중에서 가장 큰 수

greedy_3_3()
```

### 1이 될 때까지

N이 1이 될 때까지 두 과정 중 하나를 반복적으로 수행한다.

1. N에서 1을 뺀다.
2. N을 K로 나눈다. 단 나누어 떨어질때만 선택한다.

N을 1로 만드는 최소 횟수를 구한다.

예시)
25 5
출력 : 2

```python
def greedy_3_4():
    n, k = map(int, input().split())
    count = 0

    while True:
        if(n == 1):
            break
        elif(n % k != 0):
            n -= 1
        else:
            n //= k
        count += 1
    print(count)

greedy_3_4()
```


