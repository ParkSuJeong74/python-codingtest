# Implementation

> 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정

풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제이다. 피지컬을 요구하는 문제라고도 할 수 있다.

`완전탐색`은 모든 경우의 수를 주저없이 다 계산하는 해결 방법이고, `시뮬레이션`은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야하는 문제 유형이다.

메모리 제약 사항을 고려해야한다. 여러개의 리스트를 선언하는 경우 메모리 용량 제한으로 문제를 풀 수 없게 되는 경우도 있다.

또한 시간 복잡도가 O(nlogN) 이내의 알고리즘을 이용하여 문제를 풀어야한다.

## 상하좌우

N * N 크기의 정사각형 공간에서 가장 왼쪽 위 좌표가 (1,1)이고 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 시작은 항상 (1,1)이다. L(왼쪽), R(오른쪽), U(위로), D(아래로) 움직일때 좌표를 출력한다. 첫째줄에 N을 입력받고 움직임을 입력받는다.

예시)
5
R R R U D D
출력 : 3 4

```python
def greedy_4_1():
    n = int(input())
    plans = input().split()
    x, y = 1,1  
    types = ['L', 'R', 'U', 'D']
    dy = [-1,1,0,0]
    dx = [0,0,-1,1]
  
    for plan in plans:
        for i in range(len(types)):
            if plan == types[i]:
                nx = x + dx[i]
                ny = y + dy[i]
                if (nx > 0 and nx < n+1 and ny > 0 and ny < n+1):
                    x = nx
                    y = ny
    print(x, y)

greedy_4_1()
```


